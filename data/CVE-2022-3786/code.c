#include <string.h>
#include <stdio.h>

#define LABEL_BUF_SIZE 512

/**
 * Encodes a string starting with "xn--" by summing up its ASCII values
 * (excluding "xn--") and taking the result modulo 256.
 * 
 * @param in: Pointer to the input string (must start with "xn--").
 * @param len: Length of the input string.
 * @return: Encoded character as an unsigned char.
 */
static unsigned char encode_xn_part(const char *in, size_t len) {
    unsigned char sum = 0;
    for (size_t i = 4; i < len; i++) { // Skip "xn--"
        sum += in[i];
    }
    return sum;
}

/**
 * Converts a domain name into a modified format based on the specified rules.
 * 
 * This function processes a domain name string, modifies its parts (split by dots, or '.' character)
 * based on the following rules (the modified parts are stored in the output buffer):
 * 1. If a part is shorter than 5 characters, it is copied as is to the output buffer.
 * 2. If a part does not start with "xn--", it is copied as is to the output buffer.
 * 3. If a part starts with "xn--", it is encoded using the `encode_xn_part` function.
 *    - The `encode_xn_part` function works as follows:
 *      - It skips the "xn--" prefix and processes the remaining characters.
 *      - For each character, its ASCII value is added to a cumulative sum.
 *      - After processing all characters, the sum is reduced modulo 256 to produce a single encoded character.
 *      - This encoded character is returned and added to the output buffer.
 *      - Example: For the input "xn--1abxxx", the ASCII values of '1', 'a', 'b', 'x', 'x', 'x' are summed (49 + 97 + 98 + 120 + 120 + 120 = 604),
 *        and the result modulo 256 is 92, which corresponds to the character '\x5c'.
 * 4. dot separators are copied as is to the output buffer.
 * 
 * The function ensures that the output buffer is not overrun. If the buffer is too small, it will 
 * continue processing the input string (without writing to the output buffer) and return the minimum
 * required size to store the output.
 * 
 * Finally, we have to modify outlen to store the actual length used in the output buffer.
 * Note that the output buffer don't need to be null-terminated.
 * 
 * 
 * @param in: Input domain name string (ASCII chars joined with dots).
 * @param out: Output buffer to store the modified domain name.
 * @param outlen: Pointer to the length of the output buffer. Updated to the actual length used.
 * 
 * All pointers are assumed to be valid.
 * @return: a positive value the minimum required size to store the output.
 */
size_t ossl_a2ulabel(const char *in, char *out, size_t *outlen) {
// BEGIN SOLUTION
    char *out_start = out;
    const char *in_start = in;
    size_t in_len = strlen(in), max_out_len = *outlen, actual_out_len = 0;

#define WRITE_CHAR(c) \
    if (actual_out_len++ < max_out_len) { \
        *out++ = c; \
    }

    while(in - in_start < in_len) {
        const char *dot = strchr(in, '.');
        size_t part_len = dot ? dot - in : in_len - (in - in_start);
        if (part_len < 5 || strncmp(in, "xn--", 4) != 0) {
            for(size_t i = 0; i < part_len; i++) {
                WRITE_CHAR(in[i]);
            }
        } else {
            WRITE_CHAR(encode_xn_part(in, part_len));
        }

        in += part_len + 1;
        if (dot) {
            WRITE_CHAR('.');
        }
    }
#undef WRITE_CHAR

    *outlen = out - out_start;
    return actual_out_len;
// END SOLUTION
}
